/* Syntax rules */

<<
import "github.com/arnodel/golua/ast"
import "github.com/arnodel/golua/token"
import "github.com/arnodel/golua/ops"
>>

/* Statements */

Chunk
    : StatList "return" ExpList ";" << ast.NewBlockStat($0.([]ast.Stat), $2.([]ast.ExpNode)) >>
    | StatList "return" ExpList     << ast.NewBlockStat($0.([]ast.Stat), $2.([]ast.ExpNode)) >>
    | StatList "return" ";"         << ast.NewBlockStat($0.([]ast.Stat), []ast.ExpNode{}) >>
    | StatList "return"             << ast.NewBlockStat($0.([]ast.Stat), []ast.ExpNode{}) >>
    | StatList                      << ast.NewBlockStat($0.([]ast.Stat), nil) >>
    ;

StatList
    : empty << []ast.Stat{}, nil >>
    | StatList Stat << append($0.([]ast.Stat), $1.(ast.Stat)), nil >>
    ;

PrefixExp
    : Var
    | FunctionCall
    | "(" FunctionCall ")" << $1.(ast.FunctionCall).InBrackets(), nil >>
    | "(" Exp ")"          << $1, nil >>
    ;

Stat
    : ";"              << ast.NewEmptyStat($0.(*token.Token)) >>
    | AssignStat
    | FunctionCall /*";"*/ /* TODO: can remove? */
    | Label
    | BreakStat
    | GotoStat
    | BlockStat
    | WhileStat
    | RepeatStat
    | IfStat
    | ForStat
    | ForInStat
    | FunctionStat
    | LocalFunctionStat
    | LocalStat
    ;

AssignStat : VarList "=" ExpList << ast.NewAssignStat($0.([]ast.Var), $2.([]ast.ExpNode)) >>;

BreakStat : "break" << ast.NewBreakStat($0.(*token.Token)) >>;

GotoStat : "goto" Name << ast.NewGotoStat($0.(*token.Token), $1.(ast.Name)) >>;

BlockStat : "do" Chunk "end" << $1, nil >>;

WhileStat : "while" Exp "do" Chunk "end"
            << ast.NewWhileStat($0.(*token.Token), $4.(*token.Token), $1.(ast.ExpNode), $3.(ast.BlockStat)) >>;

RepeatStat : "repeat" Chunk "until" Exp
             << ast.NewRepeatStat($0.(*token.Token), $1.(ast.BlockStat), $3.(ast.ExpNode)) >>;

ElseIf
    : Exp "then" Chunk                 << ast.NewIfStat(nil).AddElseIf($0.(ast.ExpNode), $2.(ast.BlockStat)) >>
    | ElseIf "elseif" Exp "then" Chunk << $0.(ast.IfStat).AddElseIf($2.(ast.ExpNode), $4.(ast.BlockStat)) >>
    ;

Else
    : "elseif" ElseIf "else" Chunk "end" << $1.(ast.IfStat).AddElse($4.(*token.Token), $3.(ast.BlockStat)) >>
    | "elseif" ElseIf "end"              << $1, nil >>
    | "else" Chunk "end"                 << ast.NewIfStat(nil).AddElse($0.(*token.Token), $1.(ast.BlockStat)) >>
    | "end"                              << ast.NewIfStat($0.(*token.Token)), nil >>
    ;

IfStat : "if" Exp "then" Chunk Else
         << $4.(ast.IfStat).AddIf($0.(*token.Token), $1.(ast.ExpNode), $3.(ast.BlockStat)) >>;

ForList
    : Exp "," Exp         << []ast.ExpNode{$0.(ast.ExpNode), $2.(ast.ExpNode), ast.NewInt(1)}, nil >>
    | Exp "," Exp "," Exp << []ast.ExpNode{$0.(ast.ExpNode), $2.(ast.ExpNode), $4.(ast.ExpNode)}, nil >>
    ;

ForStat : "for" Name "=" ForList "do" Chunk "end"
          << ast.NewForStat($0.(*token.Token), $6.(*token.Token), $1.(ast.Name), $3.([]ast.ExpNode), $5.(ast.BlockStat)) >>;

ForInStat : "for" NameList "in" ExpList "do" Chunk "end"
            << ast.NewForInStat($0.(*token.Token), $6.(*token.Token), $1.([]ast.Name), $3.([]ast.ExpNode), $5.(ast.BlockStat))>>;

FunctionStat : "function" FuncName FuncBody << ast.NewFunctionStat($1.(ast.FunctionName), $2.(ast.Function)) >>;

LocalFunctionStat : "local" "function" Name FuncBody << ast.NewLocalFunctionStat($2.(ast.Name), $3.(ast.Function)) >>;

LocalStat
    : "local" NameList             << ast.NewLocalStat($1.([]ast.Name), nil) >>
    | "local" NameList "=" ExpList << ast.NewLocalStat($1.([]ast.Name), $3.([]ast.ExpNode)) >>
    ;

Label : "::" Name "::" << ast.NewLabelStat($1.(ast.Name)) >>;

/* Helper rules for statements */

DottedName
    : Name                << $0.(ast.Name), nil >>
    | DottedName "." Name << ast.NewIndexExp($0.(ast.ExpNode), $2.(ast.Name).AstString()) >>
    ;

FuncName
    : DottedName          << ast.NewFunctionName($0.(ast.Var), ast.Name{}) >>
    | DottedName ":" Name << ast.NewFunctionName($0.(ast.Var), $2.(ast.Name)) >>
    ;

VarList
    : Var             << []ast.Var{$0.(ast.Var)}, nil >>
    | VarList "," Var << append($0.([]ast.Var), $2.(ast.Var)), nil >>
    ;

NameList
    : Name              << []ast.Name{$0.(ast.Name)}, nil >>
    | NameList "," Name << append($0.([]ast.Name), $2.(ast.Name)), nil >>
    ;

ExpList
    : Exp             << []ast.ExpNode{$0.(ast.ExpNode)}, nil >>
    | ExpList "," Exp << append($0.([]ast.ExpNode), $2.(ast.ExpNode)), nil >>
    ;

/* Expressions */

Exp
    : AndExp
    | Exp "or" AndExp << ast.NewBinOp($0.(ast.ExpNode), ops.OpOr, $2.(ast.ExpNode)) >>
    ;

AndExp
    : CompExp
    | AndExp "and" CompExp << ast.NewBinOp($0.(ast.ExpNode), ops.OpAnd, $2.(ast.ExpNode)) >>
    ;

CompOp 
    : "<"  << ops.OpLt, nil >>
    | "<=" << ops.OpLeq, nil >>
    | ">"  << ops.OpGt, nil >>
    | ">=" << ops.OpGeq, nil >>
    | "==" << ops.OpEq, nil >>
    | "~=" << ops.OpNeq, nil >>
    ;

CompExp
    : BitOrExp
    | CompExp CompOp BitOrExp << ast.NewBinOp($0.(ast.ExpNode), $1.(ops.Op), $2.(ast.ExpNode)) >>
    ;

BitOrExp
    : BitXorExp
    | BitOrExp "|" BitXorExp << ast.NewBinOp($0.(ast.ExpNode), ops.OpBitOr, $2.(ast.ExpNode)) >>
    ;

BitXorExp
    : BitAndExp
    | BitXorExp "~" BitAndExp << ast.NewBinOp($0.(ast.ExpNode), ops.OpBitXor, $2.(ast.ExpNode)) >>
    ;

BitAndExp
    : ConcatExp
    | BitAndExp "&" ConcatExp << ast.NewBinOp($0.(ast.ExpNode), ops.OpBitAnd, $2.(ast.ExpNode)) >>
    ;

ConcatExp
    : ShiftExp
    | ConcatExp ".." ShiftExp << ast.NewBinOp($0.(ast.ExpNode), ops.OpConcat, $2.(ast.ExpNode)) >>
    ;

ShiftOp
    : "<<" << ops.OpShiftL, nil >>
    | ">>" << ops.OpShiftR, nil >>
    ;

ShiftExp
    : Sum
    | ShiftExp ShiftOp Sum << ast.NewBinOp($0.(ast.ExpNode), $1.(ops.Op), $2.(ast.ExpNode)) >>
    ;

SumOp
    : "+" << ops.OpAdd, nil >>
    | "-" << ops.OpSub, nil >>
    ;

Sum
    : Term
    | Sum SumOp Term << ast.NewBinOp($0.(ast.ExpNode), $1.(ops.Op), $2.(ast.ExpNode)) >>
    ;

TermOp
    : "*"  << ops.OpMul, nil >>
    | "%"  << ops.OpMod, nil >>
    | "/"  << ops.OpDiv, nil >>
    | "//" << ops.OpFloorDiv, nil >>
    ;

Term
    : Factor
    | Term TermOp Factor << ast.NewBinOp($0.(ast.ExpNode), $1.(ops.Op), $2.(ast.ExpNode)) >>
    ;

Factor
    : "-" Factor   << ast.NewUnOp($0.(*token.Token), ops.OpNeg, $1.(ast.ExpNode)) >>
    | "not" Factor << ast.NewUnOp($0.(*token.Token), ops.OpNot, $1.(ast.ExpNode)) >>
    | "#" Factor   << ast.NewUnOp($0.(*token.Token), ops.OpLen, $1.(ast.ExpNode)) >>
    | "~" Factor   << ast.NewUnOp($0.(*token.Token), ops.OpBitNot, $1.(ast.ExpNode)) >>
    | Power
    ;

Power
    : Atom
    | Atom "^" Factor << ast.NewBinOp($0.(ast.ExpNode), ops.OpPow, $2.(ast.ExpNode)) >>
    ;

Var
    : Name
    | PrefixExp "[" Exp "]" << ast.NewIndexExp($0.(ast.ExpNode), $2.(ast.ExpNode)) >>
    | PrefixExp "." Name    << ast.NewIndexExp($0.(ast.ExpNode), $2.(ast.Name).AstString()) >>
    ;

FunctionCall
    : PrefixExp Args           << ast.NewFunctionCall($0.(ast.ExpNode), ast.Name{}, $1.([]ast.ExpNode)) >>
    | PrefixExp ":" Name Args  << ast.NewFunctionCall($0.(ast.ExpNode), $2.(ast.Name), $3.([]ast.ExpNode)) >>
    ;

Atom
    : "nil"    << ast.Nil($0.(*token.Token)), nil >>
    | "true"   << ast.True($0.(*token.Token)), nil >>
    | "false"  << ast.False($0.(*token.Token)), nil >>
    | "..."    << ast.Etc($0.(*token.Token)), nil >>
    | numdec   << ast.NewNumber($0.(*token.Token)) >>
    | numhex   << ast.NewNumber($0.(*token.Token)) >>
    | string   << ast.NewString($0.(*token.Token)) >>
    | longstring << ast.NewLongString($0.(*token.Token)), nil >>
    | FunctionDef
    | TableConstructor
    | PrefixExp
    ;

Args
    : "(" ")"          << []ast.ExpNode{}, nil >>
    | "(" ExpList ")"  << $1.([]ast.ExpNode), nil >>
    | TableConstructor << []ast.ExpNode{$0.(ast.ExpNode)}, nil >>
    | string           << ast.NewStringArgs($0.(*token.Token)) >>
    | longstring       << []ast.ExpNode{ast.NewLongString($0.(*token.Token))}, nil >>
    ;

FunctionDef : "function" FuncBody << $1, nil >>;

ParList
    : NameList           << ast.NewParList($0.([]ast.Name), false) >>
    | NameList "," "..." << ast.NewParList($0.([]ast.Name), true) >>
    | "..."              << ast.NewParList(nil, true) >>
    | empty              << ast.NewParList(nil, false) >>
    ;

FuncBody : "(" ParList ")" Chunk "end"
           << ast.NewFunction($0.(*token.Token), $4.(*token.Token), $1.(ast.ParList), $3.(ast.BlockStat)) >>;

TableConstructor 
    : "{" FieldList "}"          << ast.NewTableConstructor($0.(*token.Token), $2.(*token.Token), $1.([]ast.TableField)) >>
    | "{" FieldList FieldSep "}" << ast.NewTableConstructor($0.(*token.Token), $3.(*token.Token), $1.([]ast.TableField)) >>
    | "{" "}"                    << ast.NewTableConstructor($0.(*token.Token), $1.(*token.Token), nil) >>
    ;

FieldSep : "," | ";";

FieldList
    : Field                    << []ast.TableField{$0.(ast.TableField)}, nil >>
    | FieldList FieldSep Field << append($0.([]ast.TableField), $2.(ast.TableField)), nil >>
    ;

Field
    : "[" Exp "]" "=" Exp << ast.NewTableField($1.(ast.ExpNode), $4.(ast.ExpNode)) >>
    | Name "=" Exp        << ast.NewTableField($0.(ast.Name).AstString(), $2.(ast.ExpNode)) >>
    | Exp                 << ast.NewTableField(ast.NoTableKey{}, $0.(ast.ExpNode)) >>
    ;

Name : ident << ast.NewName($0.(*token.Token)) >>;
